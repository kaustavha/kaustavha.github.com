{
  "source": "doc/api/all.markdown",
  "miscs": [
    {
      "textRaw": "About this Documentation",
      "name": "About this Documentation",
      "type": "misc",
      "desc": "<p>The goal of this documentation is to comprehensively explain the Luvit\nAPI, both from a reference as well as a conceptual point of view.  Each\nsection describes a built-in module or high-level concept.\n\n</p>\n<p>Where appropriate, property types, method arguments, and the arguments\nprovided to event handlers are detailed in a list underneath the topic\nheading.\n\n</p>\n<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting\nthe same information in a structured manner.  This feature is\nexperimental, and added for the benefit of IDEs and other utilities that\nwish to do programmatic things with the documentation.\n\n</p>\n<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding\n<code>.markdown</code> file in the <code>doc/api/</code> folder in luvit&#39;s source tree.  The\ndocumentation is generated using the <code>tools/doc/generate.js</code> program.\nThe HTML template is located at <code>doc/template.html</code>.\n\n</p>\n<p>There&#39;s also a lot of examples in this <a href=\"https://github.com/luvit/luvit/tree/master/examples\">repo</a> that may be helpful.  \n\n</p>\n"
    },
    {
      "textRaw": "Synopsis",
      "name": "Synopsis",
      "type": "misc",
      "desc": "<p>The luvit CLI tool can be used as a scripting platform just like node. This can be used to run lua scripts as standalone servers, clients, or other tools.\n\n</p>\n<p>This simple web server written in Luvit responds with Hello World for every request.\n\n</p>\n<pre><code>local http = require(&#39;http&#39;)\n\nhttp.createServer(function (req, res)\n  local body = &quot;Hello world\\n&quot;\n  res:setHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;)\n  res:setHeader(&quot;Content-Length&quot;, #body)\n  res:finish(body)\nend):listen(1337, &#39;127.0.0.1&#39;)\n\nprint(&#39;Server running at http://127.0.0.1:1337/&#39;)</code></pre>\n<p>To run the server, put the code into a file called <code>example.js</code> and execute\nit with using luvit\n\n</p>\n<pre><code>&gt; luvit server.lua\nServer running at http://127.0.0.1:1337/</code></pre>\n<p>This script is a standalone HTTP server, there is no need for Apache or Nginx to act as host.\nAll of the examples in the documentation can be run similarly.\n\n</p>\n"
    }
  ],
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "desc": "<p>A mutable buffer using ffi for luvit.\n\n</p>\n<p><code>buffer = require(&#39;buffer&#39;)</code>\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: buffer.Buffer",
          "type": "class",
          "name": "buffer.Buffer",
          "desc": "<p>Main buffer class\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Buffer:inspect()",
              "type": "method",
              "name": "Buffer:inspect",
              "desc": "<p>Inspect a buffer. Returns a string of hexes like <Buffer Hexes>\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Buffer:readUInt8(offset)",
              "type": "method",
              "name": "Buffer:readUInt8",
              "desc": "<p>Reads unsigned 8 bit int at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readInt8(offset)",
              "type": "method",
              "name": "Buffer:readInt8",
              "desc": "<p>Read 8 bit int at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readUInt16LE(offset)",
              "type": "method",
              "name": "Buffer:readUInt16LE",
              "desc": "<p>Read a unsigned 16 bit integer in little endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readUInt16BE(offset)",
              "type": "method",
              "name": "Buffer:readUInt16BE",
              "desc": "<p>Read a unsigned 16 bit integer in big endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readInt16LE(offset)",
              "type": "method",
              "name": "Buffer:readInt16LE",
              "desc": "<p>Read a signed 16 bit integer in little endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readInt16BE(offset)",
              "type": "method",
              "name": "Buffer:readInt16BE",
              "desc": "<p>Read a signed 16 bit integer in big endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readUInt32LE(offset)",
              "type": "method",
              "name": "Buffer:readUInt32LE",
              "desc": "<p>Read a unsigned 32 bit integer in little endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readInt32LE(offset)",
              "type": "method",
              "name": "Buffer:readInt32LE",
              "desc": "<p>Read a signed 32 bit integer in little endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:readInt32BE(offset)",
              "type": "method",
              "name": "Buffer:readInt32BE",
              "desc": "<p>Read a signed 32 bit integer in big endian at offset\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Buffer:toString([i, j])",
              "type": "method",
              "name": "Buffer:toString",
              "desc": "<p>Stringify the buffer from the ith to the jth position, or the whole thing if i and j arent specified\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "i"
                    },
                    {
                      "name": "j",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    },
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "desc": "<p>It is possible to stream data through a child&#39;s stdin, stdout, and stderr in a fully non-blocking way.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "childprocess.spawn(command, args, options)",
          "type": "method",
          "name": "spawn",
          "desc": "<p>Spawns a command line process.\n\n</p>\n<p>Since the data coming in is a stream, you may want to pass it through a filter like the luvit line emitter package\nto get lines instead. \n\n</p>\n<pre><code>function example()\n  local LineEmitter = require(&#39;line-emitter&#39;).LineEmitter\n  local childProcess = require(&#39;childprocess&#39;)\n  local function run(command, args, options)\n    local stdout, stderr = LineEmitter:new(), LineEmitter:new()\n    local child = childProcess.spawn(command, args, options)\n    child.stdout:pipe(stdout)\n    child.stderr:pipe(stderr)\n    return child, stdout, stderr\n  end\n\n  local child = run(&#39;ls&#39;, {&#39;-hal&#39;}, {})\n  child:on(&#39;data&#39;, print)\nend\n\nexample()\n\ntotal 2\ndrwxr-xr-x   31 root  wheel   1.1K Aug 21 16:39 .\ndrwxr-xr-x   31 root  wheel   1.1K Aug 21 16:39 ..</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "args"
                },
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    },
    {
      "textRaw": "Codec",
      "name": "codec",
      "desc": "<p>Utilities for working with luvit streams and codecs.\n\n</p>\n<p><code>local codec = require(&#39;codec&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "codec.wrapEmitter(emitter)",
          "type": "method",
          "name": "wrapEmitter",
          "desc": "<p>Wraps an emitter with coroutines.\nReturns read and write functions. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "emitter"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "codec.wrapStream(socket)",
          "type": "method",
          "name": "wrapStream",
          "desc": "<p>Given a raw uv_stream_t userdara, return coro-friendly read/write functions.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "socket"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "codec.chain(...)",
          "type": "method",
          "name": "chain",
          "desc": "<p>Allows one to chain coroutines\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "..."
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Codec"
    },
    {
      "textRaw": "Core",
      "name": "core",
      "desc": "<p>Core object model for luvit using simple prototypes and inheritance. We support single inheritance for classes.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "core.instanceof(obj, class)",
          "type": "method",
          "name": "instanceof",
          "desc": "<p>Given an object which inherits from a class, and a class, returns whether the object is an instance of that class.\n\n</p>\n<pre><code>&gt; em = core.Emitter:new()\n&gt; core.instanceof(em, core.Emitter)\ntrue</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                },
                {
                  "name": "class"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: core.Object",
          "type": "class",
          "name": "core.Object",
          "desc": "<p>The base object class. It provides simple prototypal inheritance and inheritable constructors. \nAll other objects inherit from this.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Object:create()",
              "type": "method",
              "name": "Object:create",
              "desc": "<p>Creates a new instance of the base object\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Object:new(...)",
              "type": "method",
              "name": "Object:new",
              "desc": "<p>Creates a new instance and calls <code>obj:initialize(...)</code> if it exists.\n</p>\n<pre><code>local Rectangle = Object:extend()\nfunction Rectangle:initialize(w, h)\n  self.w = w\n  self.h = h\nend\nfunction Rectangle:getArea()\n  return self.w * self.h\nend\nlocal rect = Rectangle:new(3, 4)\np(rect:getArea())</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "..."
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Object:extend()",
              "type": "method",
              "name": "Object:extend",
              "desc": "<p>Creates a new sub-class.\n\n</p>\n<pre><code>local Square = Rectangle:extend()\nfunction Square:initialize(w)\n  self.w = w\n  self.h = h\nend</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "core.Emitter",
          "name": "Emitter",
          "desc": "<p>This class can be used directly whenever an event emitter is needed.\n</p>\n<pre><code>local emitter = Emitter:new()\nemitter:on(&#39;foo&#39;, p)\nemitter:emit(&#39;foo&#39;, 1, 2, 3)</code></pre>\n<p>Also it can easily be sub-classed.\n</p>\n<pre><code>local Custom = Emitter:extend()\nlocal c = Custom:new()\nc:on(&#39;bar&#39;, onBar)</code></pre>\n<p>Unlike EventEmitter in node.js, Emitter class doesn&#39;t auto binds <code>self</code>\nreference. This means, if a callback handler is expecting a <code>self</code> reference,\nutils.bind() should be used, and the callback handler should have a <code>self</code> at\nthe beginning its parameter list.\n</p>\n<pre><code>function some_func(self, a, b, c) end\nemitter:on(&#39;end&#39;, utils.bind(some_func, emitter))\nemitter:emit(&#39;end&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></pre>\n",
          "methods": [
            {
              "textRaw": "Emitter:on(name. callback)",
              "type": "method",
              "name": "Emitter:on",
              "desc": "<p>Adds an event listener (<code>callback</code>) for the named event <code>name</code>.\n\n</p>\n<pre><code>em = Emitter:new()\nem:on(&#39;data&#39;, function(data) print(data) end)</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name. callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:once(name, callback)",
              "type": "method",
              "name": "Emitter:once",
              "desc": "<p>Same as <code>Emitter:on</code> except it de-registers itself after the first event.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:listenerCount(name)",
              "type": "method",
              "name": "Emitter:listenerCount",
              "desc": "<p>Returns the count of the listeners bound to an event with the name <code>name</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:emit(name, ...)",
              "type": "method",
              "name": "Emitter:emit",
              "desc": "<p>Emit a named event to all listeners with optional data arguments\n\n</p>\n<pre><code>&gt; em = Emitter:new()\n&gt; em:on(&#39;data&#39;, function(data) print(data) end)\n&gt; em:emit(&#39;data&#39;, &#39;foo&#39;)\n&#39;foo&#39;</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "..."
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:removeListener(name, callback)",
              "type": "method",
              "name": "Emitter:removeListener",
              "desc": "<p>Removes a listener so it no longer catches events\n\n</p>\n<pre><code>&gt; em = Emitter:new()\n&gt; em:on(&#39;data&#39;, function(data) print(data) end)\n&gt; em:emit(&#39;data&#39;, &#39;foo&#39;)\nfoo\n&gt; em:removeListener(&#39;data&#39;, function() em:emit(&#39;data&#39;, &#39;foo&#39;) end)\n&gt; -- nothing printed</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:removeAllListeners(name)",
              "type": "method",
              "name": "Emitter:removeAllListeners",
              "desc": "<p>Removes all listeners. Name is optional and if supplied will make it act like removeListener\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:listeners(name)",
              "type": "method",
              "name": "Emitter:listeners",
              "desc": "<p>Returns listeners for the event with name <code>name</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:wrap(name)",
              "type": "method",
              "name": "Emitter:wrap",
              "desc": "<p>Utility that binds the named method <code>self[name]</code> for use as a callback.  The\nfirst argument (<code>err</code>) is re-routed to the &quot;error&quot; event instead.\n\n\n</p>\n<pre><code>local Joystick = Emitter:extend()\nfunction Joystick:initialize(device)\n  self:wrap(&quot;onOpen&quot;)\n  FS.open(device, self.onOpen)\nend\nfunction Joystick:onOpen(fd)\n  -- and so forth\nend</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Emitter:propagate(eventName, target)",
              "type": "method",
              "name": "Emitter:propagate",
              "desc": "<p>Propagate the event to another emitter.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "target"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "core.Error",
          "name": "Error",
          "desc": "<p>This is for code that wants structured error messages.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Error:initialize(message)",
              "type": "method",
              "name": "Error:initialize",
              "desc": "<p>How to handle strings\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "message"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Core"
    },
    {
      "textRaw": "Datagram | UDP",
      "name": "datagram_|_udp",
      "desc": "<p>Node-style udp module for luvit\n\n</p>\n<p><code>local dgram = require(&#39;dgram&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "dgram.createSocket(type, callback)",
          "type": "method",
          "name": "createSocket",
          "desc": "<p>Creates a new datagram socket\nCallback is triggered every time the &#39;message&#39; event gets emitted\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "type"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: dgram.Socket",
          "type": "class",
          "name": "dgram.Socket",
          "desc": "<p>Socket extends Emitter and inherits all the events thereof.\nThe dgram Socket class encapsulates the datagram functionality. It should be created via dgram.createSocket(...)  \n\n</p>\n",
          "methods": [
            {
              "textRaw": "Socket:recvStart()",
              "type": "method",
              "name": "Socket:recvStart",
              "desc": "<p>Start receiving on socket\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Socket:recvStop()",
              "type": "method",
              "name": "Socket:recvStop",
              "desc": "<p>Stop listening on socket\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Socket:setTimeout(msecs, callback)",
              "type": "method",
              "name": "Socket:setTimeout",
              "desc": "<p>Sets a socket timeout \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:send(data, port, host, callback)",
              "type": "method",
              "name": "Socket:send",
              "desc": "<p>Sends data down the udp socket\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "port"
                    },
                    {
                      "name": "host"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:bind(port, host, options)",
              "type": "method",
              "name": "Socket:bind",
              "desc": "<p>Starts listening on the specified port and host. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host"
                    },
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:close(callback)",
              "type": "method",
              "name": "Socket:close",
              "desc": "<p>Closes a socket instance and fires the callback after cleanup\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:address()",
              "type": "method",
              "name": "Socket:address",
              "desc": "<p>Returns an object containing the address information for a socket. For UDP sockets, this object will contain address , family and port.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Socket:setBroadcast(status)",
              "type": "method",
              "name": "Socket:setBroadcast",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "status - Boolean Sets or clears the SO_BROADCAST socket option. When this option is set, UDP packets may be sent to a local interface's broadcast address. ",
                      "name": "status",
                      "desc": "Boolean Sets or clears the SO_BROADCAST socket option. When this option is set, UDP packets may be sent to a local interface's broadcast address."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "status"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets membership status for a multicast group. Op can be &#39;join&#39; or &#39;leave&#39;.\n\n</p>\n"
            },
            {
              "textRaw": "Socket:setMembership(multicastAddress[, multicastInterface], op)",
              "type": "method",
              "name": "Socket:setMembership",
              "desc": "<p>Sets membership status for a multicast group. Op can be &#39;join&#39; or &#39;leave&#39;.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "multicastInterface",
                      "optional": true
                    },
                    {
                      "name": "op"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:addMembership(multicastAddress[, interfaceAddress])",
              "type": "method",
              "name": "Socket:addMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "multicastAddress String ",
                      "name": "multicastAddress",
                      "desc": "String"
                    },
                    {
                      "textRaw": "multicastInterface String, Optional Tells the kernel to join a multicast group with IP_ADD_MEMBERSHIP socket option. ",
                      "name": "multicastInterface",
                      "desc": "String, Optional Tells the kernel to join a multicast group with IP_ADD_MEMBERSHIP socket option.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "interfaceAddress",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>If multicastInterface is not specified, the OS will try to add membership to all valid interfaces.\n\n</p>\n"
            },
            {
              "textRaw": "Socket:dropMembership(multicastAddress[, interfaceAddress])",
              "type": "method",
              "name": "Socket:dropMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "multicastAddress String ",
                      "name": "multicastAddress",
                      "desc": "String"
                    },
                    {
                      "textRaw": "multicastInterface String, Optional Opposite of addMembership - tells the kernel to leave a multicast group with IP_DROP_MEMBERSHIP socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this. ",
                      "name": "multicastInterface",
                      "desc": "String, Optional Opposite of addMembership - tells the kernel to leave a multicast group with IP_DROP_MEMBERSHIP socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "interfaceAddress",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>If multicastInterface is not specified, the OS will try to drop membership to all valid interfaces.\n\n</p>\n"
            },
            {
              "textRaw": "Socket:setTTL(ttl)",
              "type": "method",
              "name": "Socket:setTTL",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "ttl Integer Sets the IP_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded. Changing TTL values is typically done for network probes or when multicasting. ",
                      "name": "ttl",
                      "desc": "Integer Sets the IP_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded. Changing TTL values is typically done for network probes or when multicasting."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ],
              "desc": "<p>The argument to setTTL() is a number of hops between 1 and 255. The default on most systems is 64.\n\n\n</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Datagram | UDP"
    },
    {
      "textRaw": "DNS",
      "name": "dns",
      "desc": "<p>Node-style dns module for luvit\n\n</p>\n<p><code>local dns = require(&#39;dns&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "dns.setTimeout(timeout)",
          "type": "method",
          "name": "setTimeout",
          "desc": "<p>Sets the timeout to the default timeout of 2 seconds\n\n</p>\n",
          "signatures": [
            {
              "params": []
            },
            {
              "params": [
                {
                  "name": "timeout"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.setDefaultTimeout()",
          "type": "method",
          "name": "setDefaultTimeout",
          "desc": "<p>Sets the timeout to the default timeout of 2 seconds\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "dns.setDefaultServers()",
          "type": "method",
          "name": "setDefaultServers",
          "desc": "<p>Sets the list of servers to the default list \n\n</p>\n<pre><code>{\n  {\n    [&#39;host&#39;] = &#39;8.8.8.8&#39;,\n    [&#39;port&#39;] = 53,\n    [&#39;tcp&#39;] = false\n  },\n  {\n    [&#39;host&#39;] = &#39;8.8.4.4&#39;,\n    [&#39;port&#39;] = 53,\n    [&#39;tcp&#39;] = false\n  },\n}</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "dns.loadResolver(options)",
          "type": "method",
          "name": "loadResolver",
          "desc": "<p>Options is a table with key file. E,g\n</p>\n<pre><code>{file = &#39;/etc/resolv.conf&#39;}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "DNS"
    },
    {
      "textRaw": "FS",
      "name": "fs",
      "desc": "<p>Node-style filesystem module for luvit\n\n</p>\n<p><code>local fs = require(&#39;fs&#39;)</code>\n\n</p>\n<p>Uses lib uv under the hood. A lot of these fuctions are very similiar to linux system calls and can be understood by reading the man pages of linux command line commnds with the same names.\n\n</p>\n<p>The asynchronous form always takes a completion callback as its last argument. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation was completed successfully, then the first argument will be null or undefined.\n\n</p>\n<p>Sync versions of functions usually return true if they succeed or an error if they dont and no data is expected.\nOtherwise they return the data on success. \n\n</p>\n",
      "methods": [
        {
          "textRaw": "fs.close(fileDescriptor, callback)",
          "type": "method",
          "name": "close",
          "desc": "<p>Close a file. No arguments other than a possible exception are given to the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fileDescriptor"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.closeSync(fd)",
          "type": "method",
          "name": "closeSync",
          "desc": "<p>Synchronous file close\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.open(path[, flags, mode], callback)",
          "type": "method",
          "name": "open",
          "desc": "<p>Asynchronous file open. <code>flags</code> can be:\n\n</p>\n<ul>\n<li><p><code>&#39;r&#39;</code> - Open file for reading.\nAn exception occurs if the file does not exist.</p>\n</li>\n<li><p><code>&#39;r+&#39;</code> - Open file for reading and writing.\nAn exception occurs if the file does not exist.</p>\n</li>\n<li><p><code>&#39;rs&#39;</code> - Open file for reading in synchronous mode. Instructs the operating\nsystem to bypass the local file system cache.</p>\n<p>This is primarily useful for opening files on NFS mounts as it allows you to\nskip the potentially stale local cache. It has a very real impact on I/O\nperformance so don&#39;t use this flag unless you need it.</p>\n<p>Note that this doesn&#39;t turn <code>fs.open()</code> into a synchronous blocking call.\nIf that&#39;s what you want then you should be using <code>fs.openSync()</code></p>\n</li>\n<li><p><code>&#39;rs+&#39;</code> - Open file for reading and writing, telling the OS to open it\nsynchronously. See notes for <code>&#39;rs&#39;</code> about using this with caution.</p>\n</li>\n<li><p><code>&#39;w&#39;</code> - Open file for writing.\nThe file is created (if it does not exist) or truncated (if it exists).</p>\n</li>\n<li><p><code>&#39;wx&#39;</code> - Like <code>&#39;w&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;w+&#39;</code> - Open file for reading and writing.\nThe file is created (if it does not exist) or truncated (if it exists).</p>\n</li>\n<li><p><code>&#39;wx+&#39;</code> - Like <code>&#39;w+&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;a&#39;</code> - Open file for appending.\nThe file is created if it does not exist.</p>\n</li>\n<li><p><code>&#39;ax&#39;</code> - Like <code>&#39;a&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;a+&#39;</code> - Open file for reading and appending.\nThe file is created if it does not exist.</p>\n</li>\n<li><p><code>&#39;ax+&#39;</code> - Like <code>&#39;a+&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n</ul>\n<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was\ncreated. It defaults to <code>0666</code>, readable and writeable.\n\n</p>\n<p>The callback gets two arguments <code>(err, fd)</code>.\n\n</p>\n<p>The exclusive flag <code>&#39;x&#39;</code> (<code>O_EXCL</code> flag in open(2)) ensures that <code>path</code> is newly\ncreated. On POSIX systems, <code>path</code> is considered to exist even if it is a symlink\nto a non-existent file. The exclusive flag may or may not work with network file\nsystems.\n\n</p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.openSync(path, flags[, mode])",
          "type": "method",
          "name": "openSync",
          "desc": "<p>Synchronous version of <code>fs.open()</code>. Returns an integer representing the file\ndescriptor.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.read(fd, [, size, offset], callback)",
          "type": "method",
          "name": "read",
          "desc": "<p>Read data from the file specified by <code>fd</code>.\n\n</p>\n<p><code>offset</code> is the offset in the buffer to start reading at.\n\n</p>\n<p><code>size</code> is an integer specifying the number of bytes to read. Defaults to 4096.\n\n</p>\n<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                null,
                {
                  "name": "size"
                },
                {
                  "name": "offset",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readSync(fd[, size, offset])",
          "type": "method",
          "name": "readSync",
          "desc": "<p>Synchronous file read\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "size"
                },
                {
                  "name": "offset",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlink(path, callback)",
          "type": "method",
          "name": "unlink",
          "desc": "<p>Asynchronous delete file. No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlinkSync(path)",
          "type": "method",
          "name": "unlinkSync",
          "desc": "<p>Synchronous unlink. Returns <code>undefined</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.write(fd[, offset], data, callback)",
          "type": "method",
          "name": "write",
          "desc": "<p>Writes a data in string <code>data</code> to a file <code>fd</code> calling a function <code>callback</code> with \nerr or nil when done. <code>offset</code> is the offset in the buffer to start writing at.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "offset",
                  "optional": true
                },
                {
                  "name": "data"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fs[, offset,] data)",
          "type": "method",
          "name": "writeSync",
          "desc": "<p>Synchronous version of the above write function\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fs"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "] data"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdir(path[, mode], callback)",
          "type": "method",
          "name": "mkdir",
          "desc": "<p>Creates a directory with name <code>path</code> and returns a callback with err or nil.\nMode is the permissions set on the directory, defaults to octal 0777\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdirSync(path, mode)",
          "type": "method",
          "name": "mkdirSync",
          "desc": "<p>Sync version of mkdir. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdtemp(template, callback)",
          "type": "method",
          "name": "mkdtemp",
          "desc": "<p>Makes a directory from a template object\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "template"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdtempSync(template)",
          "type": "method",
          "name": "mkdtempSync",
          "desc": "<p>Sync version of mkdtemp\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "template"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdir(path, callback)",
          "type": "method",
          "name": "rmdir",
          "desc": "<p>It&#39;s like <code>rm -rf</code> but in luvit!\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdirSync(path)",
          "type": "method",
          "name": "rmdirSync",
          "desc": "<p>Sync version of rmdir\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdir(path, callback)",
          "type": "method",
          "name": "readdir",
          "desc": "<p>Reads a directory, returning files and folders in it in the callback. First arg of cb is nil or err\nThis function is not recursive. Use the luvit-walk package for a recursive variant\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdirSync(path)",
          "type": "method",
          "name": "readdirSync",
          "desc": "<p>Sync version of readdir\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.scandir(path, callback)",
          "type": "method",
          "name": "scandir",
          "desc": "<p>Similiar to readdir but the callback here gets a function instead of a table containing\nthe list of files. Every time this function is invoked it returns the name of the file/dir\nand the type of the file/dir (either file or directory).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.scandirSync(path)",
          "type": "method",
          "name": "scandirSync",
          "desc": "<p>Simply returns the iterator function retrieved in the async scandirs callback\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.exists(path, callback)",
          "type": "method",
          "name": "exists",
          "desc": "<p>Checks if a file exists. Callback is called with true or false and an error or nil in the\nfirst and second args respectively.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.existsSync(path)",
          "type": "method",
          "name": "existsSync",
          "desc": "<p>Sync version of exists. Returns the args the callback gets in the async version\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.stat(path, callback)",
          "type": "method",
          "name": "stat",
          "desc": "<pre><code>&gt; fs.stat(&#39;/&#39;, function(err, stat) print(err) statData = stat end)\nuv_fs_t: 0x00ada5c0\n&gt; nil\nstatData\n{ mtime = { nsec = 0, sec = 1440200375 },\n  atime = { nsec = 0, sec = 1444233226 }, ino = 2, nlink = 31, uid = 0,\n  blksize = 4096, ctime = { nsec = 0, sec = 1440200375 }, rdev = 0,\n  size = 1122, mode = 16877, type = &#39;directory&#39;,\n  birthtime = { nsec = 0, sec = 1428616447 }, flags = 0, gid = 0, gen = 0,\n  dev = 16777220, blocks = 0 }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.statSync(path)",
          "type": "method",
          "name": "statSync",
          "desc": "<p>Sync version of fs.stat. Returns either an error or the stat object\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstat(fd, callback)",
          "type": "method",
          "name": "fstat",
          "desc": "<p>Similiar to stat but expects a file descriptor as retrieved from open or read instead of a path\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstatSync(fd)",
          "type": "method",
          "name": "fstatSync",
          "desc": "<p>Sync fstat\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstat(path, callback)",
          "type": "method",
          "name": "lstat",
          "desc": "<p>lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstatSync(path)",
          "type": "method",
          "name": "lstatSync",
          "desc": "<p>Sync lstat\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rename(path, newPath, callback)",
          "type": "method",
          "name": "rename",
          "desc": "<p>Renames a file or directory located at the given path to the new path.\nThe callback is called with either the error or true\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.renameSync(path, newPath)",
          "type": "method",
          "name": "renameSync",
          "desc": "<p>Sync version of rename\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsync(fd, callback)",
          "type": "method",
          "name": "fsync",
          "desc": "<p>Async fsync. No arguments other than a possible exception are given to the completion callback.\n\n</p>\n<p>fsync() transfers (&quot;flushes&quot;) all modified in-core data of (i.e., modified buffer cache pages for) the file referred to by the file descriptor fd to the disk device (or other permanent storage device) so that all changed information can be retrieved even after the system crashed or was rebooted. This includes writing through or flushing a disk cache if present. The call blocks until the device reports that the transfer has completed. It also flushes metadata information associated with the file (see stat(2)).\n\n</p>\n<p>Calling fsync() does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit fsync() on a file descriptor for the directory is also needed.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsyncSync(fd)",
          "type": "method",
          "name": "fsyncSync",
          "desc": "<p>Sync version of fsync\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fdatasync(fd, callback)",
          "type": "method",
          "name": "fdatasync",
          "desc": "<p>fdatasync() is similar to fsync(), but does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be correctly handled. For example, changes to st_atime or st_mtime (respectively, time of last access and time of last modification; see stat(2)) do not require flushing because they are not necessary for a subsequent data read to be handled correctly. On the other hand, a change to the file size (st_size, as made by say ftruncate(2)), would require a metadata flush.\n\n</p>\n<p>The aim of fdatasync() is to reduce disk activity for applications that do not require all metadata to be synchronized with the disk.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fdatasyncSync(fd)",
          "type": "method",
          "name": "fdatasyncSync",
          "desc": "<p>Sync fdatasync\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncate(fname[, offset], callback)",
          "type": "method",
          "name": "ftruncate",
          "desc": "<p>Shrink or extend the size of each FILE to the specified size\n\n</p>\n<p>A FILE argument that does not exist is created.\n\n</p>\n<p>If a FILE is larger than the specified size, the extra data is lost. If a FILE is shorter, it is extended and the extended part (hole) reads as zero bytes.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fname"
                },
                {
                  "name": "offset",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncateSync(fname[, offset])",
          "type": "method",
          "name": "ftruncateSync",
          "desc": "<p>Sync truncate\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fname"
                },
                {
                  "name": "offset",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.sendFile(outFd, inFd, offset, length, callback)",
          "type": "method",
          "name": "sendFile",
          "desc": "<p>sendfile() copies data between one file descriptor and another. Because this copying is done within the kernel, sendfile() is more efficient than the combination of read(2) and write(2), which would require transferring data to and from user space.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "outFd"
                },
                {
                  "name": "inFd"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.sendfileSync(outFd, inFd, offset, length)",
          "type": "method",
          "name": "sendfileSync",
          "desc": "<p>Sync sendfile\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "outFd"
                },
                {
                  "name": "inFd"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.access(path[, flags], callback)",
          "type": "method",
          "name": "access",
          "desc": "<p>Tests a user&#39;s permissions for the file specified by path. mode is an optional integer that specifies the accessibility checks to be performed. The following constants define the possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values.\n\n</p>\n<ul>\n<li>fs.F_OK - File is visible to the calling process. This is useful for determining if a file exists, but says nothing about rwx permissions. Default if no mode is specified.</li>\n<li>fs.R_OK - File can be read by the calling process.</li>\n<li>fs.W_OK - File can be written by the calling process.</li>\n<li>fs.X_OK - File can be executed by the calling process. This has no effect on Windows (will behave like fs.F_OK).</li>\n<li>The final argument, callback, is a callback function that is invoked with a possible error argument. If any of the accessibility checks fail, the error argument will be populated. The following example checks if the file /etc/passwd can be read and written by the current process.</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmod(path, mode, callback)",
          "type": "method",
          "name": "chmod",
          "desc": "<p>Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.cmodSync(fd, mode)",
          "type": "method",
          "name": "cmodSync",
          "desc": "<p>Sync chmod.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchmod(fd, mode, callback)",
          "type": "method",
          "name": "fchmod",
          "desc": "<p>Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utime(path, atime, mtime, callback)",
          "type": "method",
          "name": "utime",
          "desc": "<p>Async utime. Chages file last access and modification times\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utimeSync(path, atime, mtime)",
          "type": "method",
          "name": "utimeSync",
          "desc": "<p>Sync utime\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futime(fd, atime, mtime, callback)",
          "type": "method",
          "name": "futime",
          "desc": "<p>Changes file timestamps\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futimeSync(fd, atime, mtime, callback)",
          "type": "method",
          "name": "futimeSync",
          "desc": "<p>Sync futime\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.link(path, newPath, callback)",
          "type": "method",
          "name": "link",
          "desc": "<p>link() creates a new link (also known as a hard link) to an existing file.\nIf newpath exists it will not be overwritten.\n\n</p>\n<p>This new name may be used exactly as the old one for any operation; both names refer to the same file (and so have the same permissions and ownership) and it is impossible to tell which name was the &quot;original&quot;.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.linkSync(path, newPath)",
          "type": "method",
          "name": "linkSync",
          "desc": "<p>Sync link\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symink(path, newPath[, option], callback)",
          "type": "method",
          "name": "symink",
          "desc": "<p>Creates soft link instead of a hard link as in link\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "option",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlinkSync(path, newPath[, options])",
          "type": "method",
          "name": "symlinkSync",
          "desc": "<p>Sync symlink\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlink(path, callback)",
          "type": "method",
          "name": "readlink",
          "desc": "<p>Asynchronous readlink(2). The callback gets two arguments (err, linkString).\nPrints value of a symbolic link or canonical file name\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlinkSync(path)",
          "type": "method",
          "name": "readlinkSync",
          "desc": "<p>Sync readlink\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chown(path, uid, gid, callback)",
          "type": "method",
          "name": "chown",
          "desc": "<p>Async chown. Changes ownership of a file\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chownSync(path, uid, gid)",
          "type": "method",
          "name": "chownSync",
          "desc": "<p>Sync chown\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchown(fd, uid, gid, callback)",
          "type": "method",
          "name": "fchown",
          "desc": "<p>Like chown but works with file descriptors\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchownSync(fd, uid, gid)",
          "type": "method",
          "name": "fchownSync",
          "desc": "<p>Sync fchown\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFile(path, callback)",
          "type": "method",
          "name": "readFile",
          "desc": "<p>Reads a file to a string buffer which is returned as the second argument in the callback. Works with virtual filesystems as well\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFileSync(path)",
          "type": "method",
          "name": "readFileSync",
          "desc": "<p>Sync readFile\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFile(path, data, callback)",
          "type": "method",
          "name": "writeFile",
          "desc": "<p>Writes a file. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "data"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFileSync(path, data)",
          "type": "method",
          "name": "writeFileSync",
          "desc": "<p>Sync writeFile\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "data"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.appendFile(filename, data[, callback])",
          "type": "method",
          "name": "appendFile",
          "desc": "<p>Appends data to a file\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.appendFileSync(path, data)",
          "type": "method",
          "name": "appendFileSync",
          "desc": "<p>Sync version of append file.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "data"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createWriteStream(path, options)",
          "type": "method",
          "name": "createWriteStream",
          "desc": "<p>Creates and returns a new write stream, that is an instance of the afore mentioned WriteStream class with the given path and options\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createReadStream(path, options)",
          "type": "method",
          "name": "createReadStream",
          "desc": "<p>Function which creates and returns a new read stream instance with the set options and path\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "fs.fchmodSync(fd, mode0",
          "name": "fs.fchmodsync(fd,_mode0",
          "desc": "<p>Sync fchmod\n\n</p>\n",
          "type": "module",
          "displayName": "fs.fchmodSync(fd, mode0"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: fs.WriteStream",
          "type": "class",
          "name": "fs.WriteStream",
          "desc": "<p>Creates a writeable stream\nYou can extend the following class methods in your extended instance.\n\n</p>\n<p>e.g.\n\n</p>\n<pre><code>local path, cb, chunk = &#39;valid/path&#39;, validFunc, &#39;validString&#39;\nlocal WritableChild = fs.WriteStream:extend()\nfunction WritableChild:_write(data, callback)\n  print(&#39;Wrote: &#39;..data)\n  callback()\nend\nlocal writable = WritableChild:new(path, cb)\nwritable:on(&#39;open&#39;, function() print(&#39;file opened&#39;)\nwritable:write(chunk) -- optional callback\nwritable:close()</code></pre>\n",
          "methods": [
            {
              "textRaw": "WriteStream:initialize(path, options)",
              "type": "method",
              "name": "WriteStream:initialize",
              "desc": "<p>You can set the path to the file and options here. Options is a table with the following key-value pairs\n\n</p>\n<ul>\n<li><p>fd - File descriptor</p>\n</li>\n<li><p>flags - &#39;w&#39; for write. See fs.open for other possible flags</p>\n</li>\n<li><p>mode - file mode to write to. Defaults to 438 which is equivalent to octal 0666</p>\n</li>\n<li><p>start - Start position</p>\n</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "WriteStream:open(callback)",
              "type": "method",
              "name": "WriteStream:open",
              "desc": "<p>Callback to fire when the write stream is opened. This callback gets no arguments\nAn open event is also emitted with the file descriptor when the file is opened\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "WriteStream:_write(data, callback)",
              "type": "method",
              "name": "WriteStream:_write",
              "desc": "<p>Internal write utility. Bind the declared <code>_write</code> in your inherited class to be called when the file is opened\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "WriteStream:close()",
              "type": "method",
              "name": "WriteStream:close",
              "desc": "<p>Closes or destroys the write stream. Calls self:destroy()\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "WriteStream:destroy()",
              "type": "method",
              "name": "WriteStream:destroy",
              "desc": "<p>Closes the write stream\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: fs.WriteStreamSync",
          "type": "class",
          "name": "fs.WriteStreamSync",
          "desc": "<p>A synchronous version of the WriteStream class. Extends WriteStream\n\n</p>\n"
        },
        {
          "textRaw": "Class: fs.ReadStream",
          "type": "class",
          "name": "fs.ReadStream",
          "desc": "<p>A parent class for creating readable streams from files\nYou should extend the following class methods in your extended instance\n\n</p>\n",
          "methods": [
            {
              "textRaw": "ReadStream:initialize(path, options)",
              "type": "method",
              "name": "ReadStream:initialize",
              "desc": "<p>Initializer for the ReadStream class. \nOptions table key values: \n<em> fd - file descriptor\n</em> mode\n<em> path\n</em> offset\n<em> chunkSize\n</em> length\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ReadStream:open(callback)",
              "type": "method",
              "name": "ReadStream:open",
              "desc": "<p>Callback to fire when the read stream is opened. This callback gets no arguments\nAn open event is also emitted with the file descriptor when the file is opened\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ReadStream:_read(n)",
              "type": "method",
              "name": "ReadStream:_read",
              "desc": "<p>Reads a file, n chunk bytes at a time. You can set the n in the init options\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "n"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ReadStream:close()",
              "type": "method",
              "name": "ReadStream:close",
              "desc": "<p>Closes the readstream. \n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "ReadStream:destroy(err)",
              "type": "method",
              "name": "ReadStream:destroy",
              "desc": "<p>Destroys the readstream. Gets called by close. Emits &#39;error&#39; with err if theres an error. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "err"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "FS"
    },
    {
      "textRaw": "Helpful",
      "name": "helpful",
      "desc": "<p>Levenshtein distance for property-not-found hints in modules.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "string.levenshtein(str1, str2)",
          "type": "method",
          "name": "levenshtein",
          "desc": "<p>Adds a levenshtein distance function to luas native string library. The string library in luvit gets auto populated \nwith luas string library and inbuilt methods. You can use it by simply going\n<code>string.levenshtein(str1, str2)</code>. No require statements needed. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str1"
                },
                {
                  "name": "str2"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Helpful"
    },
    {
      "textRaw": "HTTP Codec",
      "name": "http_codec",
      "desc": "<p>A simple pair of functions for converting between hex and raw strings.<br><code>local httpCodec = require(&#39;http-codec&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "httpCodec.encoder()",
          "type": "method",
          "name": "encoder",
          "desc": "<p>Returns a function. See the source at <a href=\"https://github.com/luvit/luvit/blob/master/deps/http.lua#L113-L199\">http.lua:ServerResponse</a> for an example.  \n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "httpCodec.decoder()",
          "type": "method",
          "name": "decoder",
          "desc": "<p>Returns a function which takes one argument. See the source at <a href=\"https://github.com/luvit/luvit/blob/master/deps/http.lua#L251-L338\">http.lua</a> for an example.  \n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTP Codec"
    },
    {
      "textRaw": "HTTP",
      "name": "http",
      "desc": "<p>Node-style http client and server module for luvit\n\n</p>\n<p><code>local http = require(&#39;http&#39;)</code>\n\n</p>\n",
      "properties": [
        {
          "textRaw": "Value: http.headerMeta",
          "name": "headerMeta",
          "desc": "<p>Provide a nice case insensitive interface to headers.\nPulled from <a href=\"https://github.com/creationix/weblit/blob/master/libs/weblit-app.lua\">https://github.com/creationix/weblit/blob/master/libs/weblit-app.lua</a>\n\n</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: http.IncomingMessage",
          "type": "class",
          "name": "http.IncomingMessage",
          "desc": "<p>Incoming message class, extends net.Socket.  \n\n</p>\n",
          "methods": [
            {
              "textRaw": "IncomingMessage:initialize(head, socket)",
              "type": "method",
              "name": "IncomingMessage:initialize",
              "desc": "<p>Head is headers. \nHeaders declared in this child class, i.e. options expected in the head table:\n</p>\n<pre><code>- version - httpVersion\n// Server specific\n- method\n- path - url\n// Client specific\n- code - statusCode\n- reason - statusMessage</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "head"
                    },
                    {
                      "name": "socket"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "IncomingMessage:_read()",
              "type": "method",
              "name": "IncomingMessage:_read",
              "desc": "<p>Resumes self.socket\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: http.ServerResponse",
          "type": "class",
          "name": "http.ServerResponse",
          "methods": [
            {
              "textRaw": "ServerResponse:finish(chunk)",
              "type": "method",
              "name": "ServerResponse:finish",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "newStatusCode"
                    },
                    {
                      "name": "newHeaders"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ServerResponse:writeHead(newStatusCode, newHeaders)",
              "type": "method",
              "name": "ServerResponse:writeHead",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "newStatusCode"
                    },
                    {
                      "name": "newHeaders"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: http.ClientRequest",
          "type": "class",
          "name": "http.ClientRequest",
          "methods": [
            {
              "textRaw": "ClientRequest:done(data, cb)",
              "type": "method",
              "name": "ClientRequest:done",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "cb"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ClientRequest:setTimeout(msecs, callback)",
              "type": "method",
              "name": "ClientRequest:setTimeout",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "http.createServer(onRequest)",
          "type": "method",
          "name": "createServer",
          "methods": [
            {
              "textRaw": "ClientRequest:done(data, cb)",
              "type": "method",
              "name": "ClientRequest:done",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "cb"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ClientRequest:setTimeout(msecs, callback)",
              "type": "method",
              "name": "ClientRequest:setTimeout",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "onRequest"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.request(options, onResponse)",
          "type": "method",
          "name": "request",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "onResponse"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "onResponse"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.get(options, onResponse)",
          "type": "method",
          "name": "get",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "onResponse"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    },
    {
      "textRaw": "HTTPS",
      "name": "https",
      "desc": "<p>Node-style https client and server module for luvit.\nHTTPS is the HTTP protocol over TLS/SSL.  \n\n</p>\n<p><code>local https = require(&#39;https&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "https.request(options, callback)",
          "type": "method",
          "name": "request",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "onResponse"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.get(options, onResponse)",
          "type": "method",
          "name": "get",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "onResponse"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTPS"
    },
    {
      "textRaw": "JSON",
      "name": "json",
      "desc": "<p><code>local json = require(&#39;json&#39;)</code>\n\n</p>\n<p>Alternatively you can use lpeg like so:\n\n</p>\n<pre><code>local json = require(&#39;json&#39;).use_lpeg()</code></pre>\n",
      "methods": [
        {
          "textRaw": "json.stringify(value [, state])",
          "type": "method",
          "name": "stringify",
          "desc": "<blockquote>\n<p>Serialize a Lua table into a JSON string.\n\n</p>\n</blockquote>\n<pre><code class=\"lua\">local tbl = { username = &quot;Groucho&quot; }\nlocal json_str = json.stringify( tbl )</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "state",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "json.encode(value[, state])",
          "type": "method",
          "name": "encode",
          "desc": "<p>Same as stringify\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "state",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "json.parse(str [, pos][, nullval][, ...])",
          "type": "method",
          "name": "parse",
          "desc": "<blockquote>\n<p>Deserialize a JSON string into a Lua table.\n\n</p>\n</blockquote>\n<pre><code class=\"lua\">local json_str = &#39;{ &quot;username&quot;: &quot;Groucho&quot; }&#39;\nlocal tbl = json.parse( json_str )</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "pos",
                  "optional": true
                },
                {
                  "name": "nullval",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "json.decode(str[, pos, nullval, ...])",
          "type": "method",
          "name": "decode",
          "desc": "<p>Same as json.parse\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "pos"
                },
                {
                  "name": "nullval"
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "json.quotestring(value)",
          "type": "method",
          "name": "quotestring",
          "desc": "<p>Quotes a string. Based on the regexp &quot;escapable&quot; in <a href=\"https://github.com/douglascrockford/JSON-js\">https://github.com/douglascrockford/JSON-js</a>\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "json.null",
          "name": "null",
          "desc": "<blockquote>\n<p>A null property type for JSON encoding.\n\n</p>\n</blockquote>\n<pre><code class=\"lua\">local tbl = { user = &quot;Jane&quot;, is_working = json.null }\nlocal json_str = json.stringify( tbl )</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "JSON"
    },
    {
      "textRaw": "Light operating system helper",
      "name": "light_operating_system_helper",
      "desc": "<p>Also known as los. \nIts&#39; a tiny helper to get os name in luvit.\n\n</p>\n<p><code>local los = require(&#39;los&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "los.type()",
          "type": "method",
          "name": "type",
          "desc": "<p>Returns either Windows, Linux, OSX, BSD, POSIX or Other depending on the host operating system.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Light operating system helper"
    },
    {
      "textRaw": "Net",
      "name": "net",
      "desc": "<p>Node-style net client and server module for luvit  \n\n</p>\n<p><code>local net = require(&#39;net&#39;)</code>\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: Socket",
          "type": "class",
          "name": "Socket",
          "methods": [
            {
              "textRaw": "Socket:initialize(options)",
              "type": "method",
              "name": "Socket:initialize",
              "desc": "<p>The Socket initializer called when an instance is generated with Socket:new()\nYou can pass in a number to options and the module will try to guess if a handler of type TCP or PIPE is required, or specify a handler\nlike so: <code>Socket:new({handle = &#39;Valid handle type&#39;})</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:resume()",
              "type": "method",
              "name": "Socket:resume",
              "desc": "<p>Works as either  \n</p>\n<pre><code>local options = {\n  host = ...,\n  port = ...\n}\nconnect(options, [cb])</code></pre>\n<p>or  \n</p>\n<pre><code>connect(port, [host, cb])</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "..."
                    }
                  ]
                },
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Socket:connect(...)",
              "type": "method",
              "name": "Socket:connect",
              "desc": "<p>Works as either  \n</p>\n<pre><code>local options = {\n  host = ...,\n  port = ...\n}\nconnect(options, [cb])</code></pre>\n<p>or  \n</p>\n<pre><code>connect(port, [host, cb])</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "..."
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:destroy(exception[, callback])",
              "type": "method",
              "name": "Socket:destroy",
              "desc": "<p>Default queueSize is 128\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "queueSize",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "exception"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:listen([queueSize])",
              "type": "method",
              "name": "Socket:listen",
              "desc": "<p>Default queueSize is 128\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "queueSize",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Socket:getsockname()",
              "type": "method",
              "name": "Socket:getsockname",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Server",
          "type": "class",
          "name": "Server",
          "methods": [
            {
              "textRaw": "Server:listen(port[, ip], callback)",
              "type": "method",
              "name": "Server:listen",
              "signatures": [
                {
                  "params": []
                },
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "ip",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Server:address()",
              "type": "method",
              "name": "Server:address",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "net.createConnection(...)",
          "type": "method",
          "name": "createConnection",
          "desc": "<p><code>createConnection(port, host, callback)</code><br>or\n<code>createConnection({port = ..., host = ..., callback = ...})</code>\n\n</p>\n<p>Creates, configures, connects and returns a new Socket instance.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "..."
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(...)",
          "type": "method",
          "name": "connect",
          "desc": "<p>Alias for net.createConnection(...)\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "..."
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createServer(options, connectionListener)",
          "type": "method",
          "name": "createServer",
          "desc": "<p>Creates, configures, initializes and returns a new Server instance.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Net"
    },
    {
      "textRaw": "Path",
      "name": "path",
      "desc": "<p>This module contains utilities for handling and transforming file paths. \nAlmost all these methods perform only string transformations. The file system is not consulted to check whether paths are valid.\nSupports both windows and posix.  \n\n</p>\n<p>Use <code>require(&#39;path&#39;)</code> to use this module. The following methods are provided:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "path.getRoot([filePath])",
          "type": "method",
          "name": "getRoot",
          "desc": "<p>Gets the filesystems root path. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filePath",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.getSep()",
          "type": "method",
          "name": "getSep",
          "desc": "<p>Gets the filesystems default path seperator\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "path.pathEquals(a, b)",
          "type": "method",
          "name": "pathEquals",
          "desc": "<p>Checks if path a is equal to b\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "a"
                },
                {
                  "name": "b"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.normalize(filepath)",
          "type": "method",
          "name": "normalize",
          "desc": "<p>Normalize a string path, taking care of &#39;..&#39; and &#39;.&#39; parts.\n\n</p>\n<p>When multiple slashes are found, they&#39;re replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.join(...)",
          "type": "method",
          "name": "join",
          "desc": "<p>Joins a splat of different strings together with the default seperator to form a valid path\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "..."
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.resolve([from ...], to)",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Works backwards, joining the arguments until it resolves to an absolute path. \nIf an absolute path is not resolved, then the current working directory is prepended\n\n</p>\n<p>E.g.\n\n</p>\n<pre><code>&gt; path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;)\n&#39;/tmp/file/&#39;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from ...",
                  "optional": true
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.relative(from, to)",
          "type": "method",
          "name": "relative",
          "desc": "<p>Returns the relative path from &#39;from&#39; to &#39;to&#39; \nIf no relative path can be solved, then &#39;to&#39; is returned\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.dirname(filepath)",
          "type": "method",
          "name": "dirname",
          "desc": "<p>Return the directory name of a path. Similar to the Unix dirname command.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.basename(filepath, expected_ext)",
          "type": "method",
          "name": "basename",
          "desc": "<p>Return the last portion of a path. Similar to the Unix basename command.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                },
                {
                  "name": "expected_ext"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.extname(filepath)",
          "type": "method",
          "name": "extname",
          "desc": "<p>Return the extension of the path, from the last &#39;.&#39; to end of string in the last portion of the path. If there is no &#39;.&#39; in the last portion of the path or the first character of it is &#39;.&#39;, then it returns an empty string. Examples:\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.isAbsolute(filepath)",
          "type": "method",
          "name": "isAbsolute",
          "desc": "<p>Checks if filepath is absolute\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.isUNC(filepath)",
          "type": "method",
          "name": "isUNC",
          "desc": "<p>Checks if the path follows Microsofts universal naming convention\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.isDriveRelative(filepath)",
          "type": "method",
          "name": "isDriveRelative",
          "desc": "<p>Drive-relative paths are unique to Windows and use the format <letter>:filepath\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.normalizeSeparators(filepath)",
          "type": "method",
          "name": "normalizeSeparators",
          "desc": "<p>Returns file path with posix seperators\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filepath"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Path"
    },
    {
      "textRaw": "Pretty print",
      "name": "pretty_print",
      "desc": "<p>A lua value pretty printer and colorizer for terminals.  \n\n</p>\n<p><code>local prettyPrint = require(&#39;pretty-print&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "prettyPrint.loadColors([index])",
          "type": "method",
          "name": "loadColors",
          "desc": "<p>Index lets you optionally pick a theme, 16 or 256. \n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "index",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "prettyPrint.print(...)",
          "type": "method",
          "name": "print",
          "desc": "<p>Works like the default lua print function. We also override the default lua print function\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "..."
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "Value: prettyPrint.theme",
          "name": "theme",
          "desc": "<p>Table of keys and values of the available themes\n\n</p>\n"
        },
        {
          "textRaw": "Userdata Value: prettyPrint.stdout",
          "name": "stdout"
        },
        {
          "textRaw": "Userdata Value: prettyPrint.stderr",
          "name": "stderr"
        }
      ],
      "type": "module",
      "displayName": "Pretty print"
    },
    {
      "textRaw": "Process",
      "name": "process",
      "desc": "<p>Node-style global process table for luvit\n\n</p>\n<p><code>local process = require(&#39;process&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "process.globalProcess()",
          "type": "method",
          "name": "globalProcess",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Process"
    },
    {
      "textRaw": "Query String",
      "name": "query_string",
      "desc": "<p>This module provides utilities for dealing with query strings.\nIt provides the following methods:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "querystring.stringify(obj[, sep][, eq][, options])",
          "type": "method",
          "name": "stringify",
          "desc": "<p>Serialize an object to a query string.\nOptionally override the default separator (<code>&#39;&amp;&#39;</code>) and assignment (<code>&#39;=&#39;</code>)\ncharacters.\n\n</p>\n<p>Options object may contain <code>encodeURIComponent</code> property (<code>querystring.escape</code> by default),\nit can be used to encode string with <code>non-utf8</code> encoding if necessary.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; })\n// returns\n&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\n\nquerystring.stringify({foo: &#39;bar&#39;, baz: &#39;qux&#39;}, &#39;;&#39;, &#39;:&#39;)\n// returns\n&#39;foo:bar;baz:qux&#39;\n\n// Suppose gbkEncodeURIComponent function already exists,\n// it can encode string with `gbk` encoding\nquerystring.stringify({ w: &#39;中文&#39;, foo: &#39;bar&#39; }, null, null,\n  { encodeURIComponent: gbkEncodeURIComponent })\n// returns\n&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.parse(str[, sep][, eq][, options])",
          "type": "method",
          "name": "parse",
          "desc": "<p>Deserialize a query string to an object.\nOptionally override the default separator (<code>&#39;&amp;&#39;</code>) and assignment (<code>&#39;=&#39;</code>)\ncharacters.\n\n</p>\n<p>Options object may contain <code>maxKeys</code> property (equal to 1000 by default), it&#39;ll\nbe used to limit processed keys. Set it to 0 to remove key count limitation.\n\n</p>\n<p>Options object may contain <code>decodeURIComponent</code> property (<code>querystring.unescape</code> by default),\nit can be used to decode a <code>non-utf8</code> encoding string if necessary.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>querystring.parse(&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;)\n// returns\n{ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\n\n// Suppose gbkDecodeURIComponent function already exists,\n// it can decode `gbk` encoding string\nquerystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,\n  { decodeURIComponent: gbkDecodeURIComponent })\n// returns\n{ w: &#39;中文&#39;, foo: &#39;bar&#39; }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.urlencode(str)",
          "type": "method",
          "name": "urlencode",
          "desc": "<p>Escapes special characters in a url\n\n</p>\n<pre><code>querystring.urlencode(&#39;https://github.com/luvit/luvit/blob/master/deps/querystring.lua&#39;)</code></pre>\n<p>Returns\n</p>\n<pre><code>&#39;https%3A%2F%2Fgithub%2Ecom%2Fluvit%2Fluvit%2Fblob%2Fmaster%2Fdeps%2Fquerystring%2Elua&#39;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.urldecode(str)",
          "type": "method",
          "name": "urldecode",
          "desc": "<p>Un-escapes special characters in a url\n\n</p>\n<pre><code>querystring.urldecode(&#39;https%3A%2F%2Fgithub%2Ecom%2Fluvit%2Fluvit%2Fblob%2Fmaster%2Fdeps%2Fquerystring%2Elua&#39;)</code></pre>\n<p>Returns\n</p>\n<pre><code>&#39;https://github.com/luvit/luvit/blob/master/deps/querystring.lua&#39;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Query String"
    },
    {
      "textRaw": "Readline",
      "name": "readline",
      "desc": "<p>A readline interface for terminals in pure lua.\n\n</p>\n<p><code>local readline = require(&#39;readline&#39;)</code>\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: readline.History",
          "type": "class",
          "name": "readline.History",
          "methods": [
            {
              "textRaw": "History:dump()",
              "type": "method",
              "name": "History:dump",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "line"
                    }
                  ]
                },
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "History:updateLastLine(line)",
              "type": "method",
              "name": "History:updateLastLine",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "line"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "Class readline.Editor",
          "name": "Editor",
          "methods": [
            {
              "textRaw": "Editor:onKey(key)",
              "type": "method",
              "name": "Editor:onKey",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prompt"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Editor:readLine(prompt, callback)",
              "type": "method",
              "name": "Editor:readLine",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prompt"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "readline.readLine(prompt[, options], callback)",
          "type": "method",
          "name": "readLine",
          "signatures": [
            {
              "params": [
                {
                  "name": "prompt"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Readline"
    },
    {
      "textRaw": "Repl",
      "name": "repl",
      "desc": "<p>Implementation of a read-execute-print-loop in Luvit. Used by the Luvit repl which is returned when the Luvit binary is executed without args.<br>Some of the examples/samples in these docs are generated by running luvit code in this repl.<br>Additionally require names in the docs follow the ones automatically added into the repl during bootup (e.g. pretty-print is name-spaced as prettyPrint in the repl).<br>All the luvit deps are injected into the repl at runtime to make it easier to try and experiment with the luvit ecosystem.  \n\n</p>\n",
      "type": "module",
      "displayName": "Repl"
    },
    {
      "textRaw": "Require",
      "name": "require",
      "desc": "<p>Luvit&#39;s custom require system with relative requires and sane search paths.<br>This allows us to have the convenience of having node style require statements to include libraries. \n\n</p>\n",
      "type": "module",
      "displayName": "Require"
    },
    {
      "textRaw": "Stream",
      "name": "stream",
      "desc": "<p>A port of node.js&#39;s stream module for luvit.\n\n</p>\n<p><code> local Stream = require(&#39;Stream&#39;)</code>\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: Stream.Stream",
          "type": "class",
          "name": "Stream.Stream",
          "desc": "<p>This is the stream core or base.\nExtends the emitter class described in Core.\n\n</p>\n<p>You will most likely not use this class. The only relevant part of this class, the pipe method, is overriden in Readable.\n\n</p>\n"
        },
        {
          "textRaw": "Class: Stream.ReadableState",
          "type": "class",
          "name": "Stream.ReadableState",
          "desc": "<p>Used to hold state by the Readable class\n\n</p>\n",
          "methods": [
            {
              "textRaw": "ReadableState:initialize(options, stream)",
              "type": "method",
              "name": "ReadableState:initialize",
              "desc": "<p>Options table:\n\n</p>\n<ul>\n<li>HighWaterMark - Defaults to 16, maxes out at 128MB. 128MB limit cannot be overwritten without modifying luvit/deps/stream/stream_readable</li>\n<li>objectMode - If false/nil then the highWaterMark is set to 16 * 1024</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "stream"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Stream.Readable",
          "type": "class",
          "name": "Stream.Readable",
          "desc": "<p>Extends Stream.Stream, implements a readable stream interface. \nUses ReadableState to keep track of self._readableState\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Readable:push(chunk)",
              "type": "method",
              "name": "Readable:push",
              "desc": "<p>Manually shove something into the read buffer. \nThis returns true if the highWaterMark has not been hit yet, similar to how Writable.write() returns true if you should write() some more.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:unshift(chunk)",
              "type": "method",
              "name": "Readable:unshift",
              "desc": "<p>Unshift should <em>always</em> be something directly out of read()\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:read(n)",
              "type": "method",
              "name": "Readable:read",
              "desc": "<p>Reads and returns n chunk bytes\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "n"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:_read(n)",
              "type": "method",
              "name": "Readable:_read",
              "desc": "<p>Internal method executed by Readable:read. Can be overwritten in child classes. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "n"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:unpipe(dest)",
              "type": "method",
              "name": "Readable:unpipe",
              "desc": "<p>Removes pipes to dest\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "dest"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:on(ev, fn)",
              "type": "method",
              "name": "Readable:on",
              "desc": "<p>Triggers a callback <code>fn</code> when an event <code>ev</code> is triggered. \nE.g.\n</p>\n<pre><code>&gt; local child = require(&#39;stream&#39;).Readable\n&gt; child:on(&#39;foo&#39;, function() print(&#39;bar&#39;) end)\n&gt; child:emit(&#39;foo&#39;)\n&#39;bar&#39;\n&gt; child:on(&#39;bar&#39;, function(data) print(data) end)\n&gt; child:emit(&#39;bar&#39;, &#39;foo&#39;)\n&#39;foo&#39;</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "ev"
                    },
                    {
                      "name": "fn"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Readable:resume()",
              "type": "method",
              "name": "Readable:resume",
              "desc": "<p>Resumes a stream\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Readable:pause()",
              "type": "method",
              "name": "Readable:pause",
              "desc": "<p>Pauses a stream\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "Readable.addListener",
              "name": "addListener",
              "desc": "<p>Alias for Readable:on<br>You can use Readable:addListener for an implicit self or use Readable.addListener(self, ...)\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: Stream.WriteReq",
          "type": "class",
          "name": "Stream.WriteReq",
          "desc": "<p>Used internally within the Writable class.  \n\n</p>\n"
        },
        {
          "textRaw": "Class: Stream.WritableState",
          "type": "class",
          "name": "Stream.WritableState",
          "desc": "<p>Used internally within the Writable class to hold state.  \n\n</p>\n",
          "methods": [
            {
              "textRaw": "WritableState:initialize(options, stream)",
              "type": "method",
              "name": "WritableState:initialize",
              "desc": "<p>Options table:\n\n</p>\n<ul>\n<li>HighWaterMark - Defaults to 16, maxes out at 128MB. 128MB limit cannot be overwritten without modifying luvit/deps/stream/stream_readable</li>\n<li>objectMode - If false/nil then the highWaterMark is set to 16 * 1024</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "stream"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Stream.Writable",
          "type": "class",
          "name": "Stream.Writable",
          "desc": "<p>The writable stream class<br>Emits <code>end</code> when done  \n\n</p>\n",
          "methods": [
            {
              "textRaw": "Writable:initialize(options)",
              "type": "method",
              "name": "Writable:initialize",
              "desc": "<p>You can modify the writable state options here, or set them.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Writable:write(chunk, cb)",
              "type": "method",
              "name": "Writable:write",
              "desc": "<p>Manually write a chunk\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "cb"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Writable:cork()",
              "type": "method",
              "name": "Writable:cork",
              "desc": "<p>Kind of like pause\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Writable:uncork()",
              "type": "method",
              "name": "Writable:uncork",
              "desc": "<p>Kind of like resume\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Stream.Duplex",
          "type": "class",
          "name": "Stream.Duplex",
          "desc": "<p>A Duplex stream is both readable and writable and inherits the functionality and methods of the aforementioned readable and writable classes.  \n\n</p>\n",
          "methods": [
            {
              "textRaw": "Duplex:initialize(options)",
              "type": "method",
              "name": "Duplex:initialize",
              "desc": "<p>These options are passed along to the initializers of the readable and writable streams this class uses.<br>Furthermore, we can have the following key values in the options table.\n\n</p>\n<ul>\n<li>readable - false/true</li>\n<li>writable - false/true</li>\n<li>allowHalfOpen - false/true</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Stream.Transform",
          "type": "class",
          "name": "Stream.Transform",
          "desc": "<p>a transform stream is a readable/writable stream where you do\nsomething with the data.  Sometimes it&#39;s called a &quot;filter&quot;,\nbut that&#39;s not a great name for it, since that implies a thing where\nsome bits pass through, and others are simply ignored.  (That would\nbe a valid example of a transform, of course.)\n\n</p>\n<p>While the output is causally related to the input, it&#39;s not a\nnecessarily symmetric or synchronous transformation.  For example,\na zlib stream might take multiple plain-text writes(), and then\nemit a single compressed chunk some time in the future.\n\n</p>\n<p>Here&#39;s how this works:\n\n</p>\n<p>The Transform stream has all the aspects of the readable and writable\nstream classes.  When you write(chunk), that calls _write(chunk,cb)\ninternally, and returns false if there&#39;s a lot of pending writes\nbuffered up.  When you call read(), that calls _read(n) until\nthere&#39;s enough pending readable data buffered up.\n\n</p>\n<p>In a transform stream, the written data is placed in a buffer.  When\n_read(n) is called, it transforms the queued up data, calling the\nbuffered _write cb&#39;s as it consumes chunks.  If consuming a single\nwritten chunk would result in multiple output chunks, then the first\noutputted bit calls the readcb, and subsequent chunks just go into\nthe read buffer, and will cause it to emit &#39;readable&#39; if necessary.\n\n</p>\n<p>This way, back-pressure is actually determined by the reading side,\nsince _read has to be called to start processing a new chunk.  However,\na pathological inflate type of transform can cause excessive buffering\nhere.  For example, imagine a stream where every byte of input is\ninterpreted as an integer from 0-255, and then results in that many\nbytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n1kb of data being output.  In this case, you could write a very small\namount of input, and end up with a very large amount of output.  In\nsuch a pathological inflating mechanism, there&#39;d be no way to tell\nthe system to stop doing the transform.  A single 4MB write could\ncause the system to run out of memory.\n\n</p>\n<p>However, even in such a pathological case, only a single written chunk\nwould be consumed, and then the rest would wait (un-transformed) until\nthe results of the previous transformed chunk were consumed.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Transform:initialize(options)",
              "type": "method",
              "name": "Transform:initialize",
              "desc": "<p>Extendable initializer for the Transform class. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Transform:_transform(chunk, cb)",
              "type": "method",
              "name": "Transform:_transform",
              "desc": "<p>The internal transform method. You must define this in your child class. \nE.g. Implement a passthrough filter aka a very fancy way to print hello world\n</p>\n<pre><code>local Transform = require(&#39;stream&#39;).Transform\nlocal Transformer = Transform:extend()\nfunction Transformer:initialize()\n  Transform.initialize(self, {objectMode = true})\nend\n\nfunction Transformer:_transform(line, cb)\n  self:push(line)\n  return cb()\nend\n\nlocal transformer = Transformer:new()\ntransformer:on(&#39;data&#39;, print)\ntransformer:write(&#39;hello world&#39;)</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "cb"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Stream.PassThrough",
          "type": "class",
          "name": "Stream.PassThrough",
          "desc": "<p>An extension of the transform stream class with the transform method declared.<br>Basically just the most minimal sort of Transform stream. \nEvery written chunk gets output as-is.\n\n</p>\n"
        },
        {
          "textRaw": "Class: Stream.Observable",
          "type": "class",
          "name": "Stream.Observable",
          "desc": "<p>Observable is a stream that can be observed outside the pipeline. observe() \nreturns a new Readable stream that emits all data that passes through this \nstream. Streams created by observe() do not affect back-pressure.\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Stream"
    },
    {
      "textRaw": "Thread",
      "name": "thread",
      "desc": "<p>Thread module for luvit  \n\n</p>\n<p><code>local thread = require(&#39;thread&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "thread.queue(worker, ...)",
          "type": "method",
          "name": "queue",
          "desc": "<p>Luvit threadpool\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Worker:queue(...)",
              "type": "method",
              "name": "Worker:queue",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "..."
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "worker"
                },
                {
                  "name": "..."
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: thread.Worker",
          "type": "class",
          "name": "thread.Worker",
          "desc": "<p>Luvit threadpool\n\n</p>\n",
          "methods": [
            {
              "textRaw": "Worker:queue(...)",
              "type": "method",
              "name": "Worker:queue",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "..."
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Thread"
    },
    {
      "textRaw": "Timer",
      "name": "timer",
      "desc": "<p>Javascript style setTimeout and setInterval for luvit  \n\n</p>\n<p><code>local timer = require(&#39;timer&#39;)</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "timer.clearInterval(timer)",
          "type": "method",
          "name": "clearInterval",
          "desc": "<p>Alias for clearInterval\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timer"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "timer"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "timer.clearTimeout(timer)",
          "type": "method",
          "name": "clearTimeout",
          "desc": "<p>Alias for clearInterval\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timer"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "timer.clearTimer(timer)",
          "type": "method",
          "name": "clearTimer",
          "desc": "<p>Alias for clearTimeout\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timer"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "timer.enroll(time, msecs)",
          "type": "method",
          "name": "enroll",
          "signatures": [
            {
              "params": [
                {
                  "name": "item"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "time"
                },
                {
                  "name": "msecs"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "timer.active(item)",
          "type": "method",
          "name": "active",
          "signatures": [
            {
              "params": [
                {
                  "name": "item"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Timer"
    },
    {
      "textRaw": "URL",
      "name": "url",
      "desc": "<p>Node-style url codec for luvit\n\n</p>\n",
      "methods": [
        {
          "textRaw": "url.parse(url[, parseQueryString])",
          "type": "method",
          "name": "parse",
          "desc": "<p>Takes a url string, returns an object\nOptional second argument of type bool. Pass in true if you&#39;d like to pass the query part of the url through the\nquerystring modules parse function.\n\n</p>\n<pre><code>url = require(&#39;url&#39;)\nurl.parse(&#39;https://github.com/luvit/luvit/blob/master/deps/url.lua&#39;)</code></pre>\n<p>Returns\n</p>\n<pre><code>{ host = &#39;github.com&#39;, hostname = &#39;github.com&#39;, href = &#39;https://github.com/luvit/luvit/blob/master/deps/url.lua&#39;, protocol = &#39;https&#39;,\n  pathname = &#39;/luvit/luvit/blob/master/deps/url.lua&#39;, path = &#39;/luvit/luvit/blob/master/deps/url.lua&#39; }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "parseQueryString",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "URL"
    },
    {
      "textRaw": "Utils",
      "name": "utils",
      "desc": "<p>Wrapper around pretty-print with extra tools for luvit\n\n</p>\n<p><code>local utils = require(&#39;utils&#39;)</code>\n\n</p>\n<p>Everything in pretty-print is available under the utils namespace as well. \nAdditionally utils has the following available functions\n\n</p>\n",
      "methods": [
        {
          "textRaw": "utils.noop(err)",
          "type": "method",
          "name": "noop",
          "desc": "<p>Used heavily within luvit to wrap luv methods and expose them.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "c"
                },
                {
                  "name": "fn"
                },
                {
                  "name": "..."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "err"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "utils.adapt(c, fn, ...)",
          "type": "method",
          "name": "adapt",
          "desc": "<p>Used heavily within luvit to wrap luv methods and expose them.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "c"
                },
                {
                  "name": "fn"
                },
                {
                  "name": "..."
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Utils"
    }
  ]
}
